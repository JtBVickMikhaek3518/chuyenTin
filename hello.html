<!doctype html>
<html>
    <head>
        <title>BINARY SEARCH (2 cơ)</title>
        <meta charset='utf-8'/>
        <link rel="stylesheet" type="text/css" href="./hello.html_files/github-markdown.css">
        <style>
            .markdown-body {
                box-sizing: border-box;
                min-width: 200px;
                max-width: 980px;
                margin: 0 auto;
                padding: 45px;
            }
        </style>
        <script>
            window.onload = function() {
                if (document.querySelector("script[type=\"math/tex; mode=display\"]") !== null) {
                    var mathjax = document.createElement("script");
                    mathjax.src = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML";
                    document.head.appendChild(mathjax);
                }
                if (document.getElementsByTagName("code").length !== 0) {
                    var highlight = document.createElement("script");
                    var highlightcss = document.createElement("link");
                    highlight.src = "http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/highlight.min.js";
                    highlightcss.rel = "stylesheet";
                    highlightcss.href = "http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/github.min.css";
                    highlight.onload = function() {hljs.initHighlighting();};
                    document.head.appendChild(highlight);
                    document.head.appendChild(highlightcss);
                }
            }
        </script>
    </head>
    <body>
        <article class="markdown-body">
            <h1 id="binary-search-2-c%C6%A1">BINARY SEARCH (2 cơ)</h1>
<p>Tìm trên dãy thứ tự: Dùng 2 con trỏ <script type="math/tex">l,r</script> ngược chiều làm phạm vi tìm <script type="math/tex">x</script> trên dãy thứ tự <script type="math/tex">A</script>, lấy <script type="math/tex">m</script> là trung điểm phần nguyên <script type="math/tex">l,r</script>. Nếu <script type="math/tex">A_m=x</script> thì <code>ret</code> <script type="math/tex">m</script>, <script type="math/tex">A_m\lt x</script> thì chặt <script type="math/tex">l</script>, <script type="math/tex">A_m>x</script> thì chặt <script type="math/tex">r</script>.</p>
<ul>
<li>Điều kiện: <script type="math/tex">A_1\leq A_2\leq...\leq A_n</script></li><li><p>Cài đặt:</p>
<pre><code>sort(a, a + n); // Sắp xếp dãy
int bs(int a[], int n, int x) {
  int l = 0, r = n - 1, m;

  while (l &lt;= r) { // Đến khi phạm vi &lt; 0
      m = l + (r - l) / 2; // Trung điểm

      if (a[m] == x) return m;
      if (a[m] &lt; x) l = m + 1; // Chặt l
      else { r = m - 1; } // Chặt r
  } return -1; // k0 tìm thấy
}
</code></pre></li></ul>
<h2 id="c%E1%BA%A3i-ti%E1%BA%BFn-lower-bound-lwb">Cải tiến: Lower Bound (lwb)</h2>
<p>Mục đích: Tìm <script type="math/tex">\min(i)</script> để <script type="math/tex">A_{\min(i)}\geq x</script>. K0 có thì <code>ret</code> <script type="math/tex">n</script>.</p>
<ul>
<li><p>Cài đặt:</p>
<pre><code>int lwb(int a[], int n, int x) {
  int l = 0, r = n - 1, m, ans = n;

  while (l &lt;=r) {
      m = (l + r) / 2;

      if (a[m] &gt;= x) {
          ans = m;
          r = m - 1;
      } else {
          l = m + 1;
      }
  } return ans;
}
</code></pre></li><li>Fact: Có thể dùng hàm sẵn std::lower_bound của STL, dùng trỏ giá trị (<code>*</code>) khi muốn lấy giá trị.</li><li>Tĩnh: <code>*lower_bound(a, a + n, x);</code></li><li>Vector: <code>*lower_bound(a.begin(), a.end(), x);</code></li><li>Nếu cần so sánh cách riêng thì xây hàm comp, sau thì viết: <code>lower_bound(&lt;đầu&gt;,&lt;kết&gt;,&lt;tìm&gt;,comp);</code></li></ul>

        </article>
    </body>
</html>
